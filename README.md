# elb-instance-manager

A simple HTTP service to manage instances in a ELB 

## Prerequisites

To be able to develop and execute the tasks is expected that you have the following tools installed:

 - `terraform`: To apply the infrastructure recipes. The version must be higher than `1.0.5`
 - `docker`: To create the Docker image and publish it to a image registry
 - `python3`: To be able to run the code and develop

And you **must** need to do the configuration setup, that is describe in the 
[Configuring the project](#configuring-the-project) section below.

## Commands

There are a series of commands that are used to do common tasks. These commands are described in 
the list below:

- `setup`: Install project dependencies & requirements and initialize the Terraform working directory
- `clean`: Clean some python autogenerated files 
- `build-image`: Build the ELB Instance Manager docker image. It's build the `latest` and the current application version tags
- `plan`: Generates a speculative execution plan, showing what actions Terraform would take to apply the ELB Instance Manager infrastructure
- `deploy-infra`: Creates or updates the ELB Instance Manager infrastructure
- `deploy`: Executes a full deployment: Build the docker image, push the image to a registry and creates or updates the ELB Instance Manager infrastructure
- `release`: Build the ELB Instance Manager docker image (using the `build-image` command) and push the image to a registry
- `bump-version-patch`: Increase the application patch version. E.g: 0.1.0 -> 0.1.1
- `bump-version-minor`: Increase the application minor version. E.g: 0.1.0 -> 0.2.0
- `test`: Runs tests
- `run`: Runs the ELB Instance Manager application locally

To run the commands just execute:
```
make [command]
```

Exemple:
```
make run
make deploy
```

## Configuring the project

:warning: **It must be the first action did in this project, as all the other tasks depends on this configuration!**

This project depends from some external dependencies like where the infrastructure will be created and the docker image will be pulled and/or pushed. It's necessary because the VPC and subnets will be different according the your environment (and the fous of this project is not to create an entire VPC infrastructure just to run it). And for the docker image repository, it probably requires an authentication, so it's better to configure you own repository in a registry to pull and/or push the images.

To configure the project you just need to edit and fill the [`config.json`](config.json) file:

- `region`: The AWS region where to create the infrastructure resources
- `vpc_id`: The ID of the AWS VPC where to create the infrastructure resources
- `public_subnet_ids`: The IDs of the **public subnet** where to create the instance and ALB. **It must be at least two public subnet ids as it's a requirement to create an ALB!**
- `docker_image`: The name of the docker image. **It'll be used by the docker commands to build and push the image and to run inside the EC2 instance**

Example:
```json
{
  "region": "us-east-1",
  "vpc_id": "vpc-09a83111626611111",
  "public_subnet_ids": ["subnet-08800d108ed223344", "subnet-0235f7e1d9e556677"],
  "docker_image": "dnicoleti/elb-instance-manager"
}
```

You also need to run the following command to finish the project setup:
```
make setup
```

## How to run the application locally

You can run the ELB Instance Manager locally running the following command:
```
make run
```


## How to deploy

There is two ways to deploy the application: just the infrastructure using my docker image or a complete deploy.

### Deploying just the infrastructure

If you don't wanna to build your own image you could use my provided image, that can be fould here: https://hub.docker.com/r/dnicoleti/elb-instance-manager/tags, and just deploy the infrastructure.

To do it you need to have already did the configuration setup and use my docker repository in the `docker_image` variable in the `config.json` file like this way:
```json
{
  "docker_image": "dnicoleti/elb-instance-manager"
}
```

The only requisite is that the `VERSION` file contains a valid version (like `0.2.0`) that have an tag published.

To deploy just the infrastructure run:
```
make deploy-infra
```

:warning: The user used to run the commands **must have** permission to create all the resources in the AWS account.

### Complete deploy

The full deployment will build and publish the docker image to the repository defined in the `config.json` file, and after that it will run Terraform to create the infrastructure in the AWS account (the same way described in the [Deploying just the infrastructure](#deploying-just-the-infrastructure) section above).

To it work correctly you can fill the `docker_image` variable in the `config.json` file like this way:
```json
{
  "docker_image": "mycompany/elb-instance-manager" 
}
```

The only requisites is that docker **must be able to publish to this repository** (probably will need to do a `docker login` do authenticate on it) and it **must be a public repositoiry** because the EC2 instance need to pull the image.

To do a full deployment run:
```
make deploy
```

## How to bump project version

To bump the project version you can run one of the following commands:
```sh
make bump-version-minor
# or
make bump-version-patch 
```

## Project architecture

The project contains two main parts:

- **The application**: The application code is mainly inside the `elb_instance_manager` directory and it implements from scratch the swagger spec, that is present in the `docs/swagger-file.yaml` file.
- **Infrastructure**: The infrastructure code is inside the `deployments` directory, and its a Terraform module that will create all the resources to run the ELB Instance Manager in a AWS account (ALB, Security groups, Roles, EC2, etc)

The infrastructure is basically a EC2 instance that will run the ELB Instance Manager docker image exposing it through the 80 port and exposed through an ALB called `default-alb`. Terraform will output the ALB address and instace public IP address, so you are able to use it.

The deployment is done in the following way:
- It read the `VERSION` file that contains the current application version. 
- With this value it will build and publish the docker image
- After building the image, it'll run a `terraform apply` passing the `config.json` file as variable file and a standalone variable called `docker_tag` that use the same value used to build and public the image (the one inside the `VERSION` file)

## Usage examples

Some examples of HTTP calls to the ELB Instance Manager:

Check the application health:
```
curl http://127.0.0.1:5000/healthcheck 
```

List instances registered in an ALB:
```
curl http://127.0.0.1:5000/elb/default-alb
```

Register an instance on an ALB:
```
curl -H "Content-Type:application/json" -d '{"instanceId": "i-06060a1e235609999"}' \
    -X POST http://127.0.0.1:5000/elb/default-alb
```

Deregister an instance from an ALB:
```
curl -H "Content-Type:application/json" -d '{"instanceId": "i-06060a1e235609999"}' \
    -X DELETE http://127.0.0.1:5000/elb/default-alb
```

## Roadmap

There are a lot of things to do and improvements that could be done in next versions:
- Add a CI/CD to the project
- Move the application to container solution (like ECS or Kubernetes) instead of run it inside an EC2
- Improve application tests (As I don't have much proficiency in Python and time to do it laked an appropriate test suite)
- Add support for other types of ELBs: Classic, NLB and GLB
- Add a check to verify if all prerequisites exists (Terraform, Docker and Python)
- Add a interative command (or use the `setup` command) to ask for the required configuration and build the `config.json` file automatically
- Use a better backend for Terraform, instead of a local backend
- And probably a lot more!

Have fun! :beer:
